# -*- coding: utf-8 -*-
"""education_loan_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rG3RFgUjgJXwZXSTY50TEN-9ZPpnyzUW
"""

import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime
import plotly.express as px

# ---------------------------------------------------------
# A. Helper function to fetch the annual interest rate for a given date
#    based on a user-defined "rate schedule."
# ---------------------------------------------------------
def get_annual_rate_for_date(date, df_rate_schedule, default_rate):
    """
    df_rate_schedule: DataFrame with columns ['effective_date','annual_rate']
       - 'effective_date' indicates from that date onward, a certain rate applies
    default_rate: if no schedule is provided or if date < earliest schedule date
    returns an annual interest rate in decimal form (e.g. 0.084 for 8.4%)
    """
    if df_rate_schedule.empty:
        return default_rate

    # Ensure date columns are datetime
    df_rate_schedule['effective_date'] = pd.to_datetime(df_rate_schedule['effective_date'])
    df_rate_schedule = df_rate_schedule.sort_values('effective_date')

    # Filter schedule rows where effective_date <= the current date
    applicable = df_rate_schedule[df_rate_schedule['effective_date'] <= date]
    if applicable.empty:
        # If the date is before the first effective_date, return default
        return default_rate
    else:
        # Return the most recent rate that started on or before this date
        latest_row = applicable.iloc[-1]
        return latest_row['annual_rate']

# ---------------------------------------------------------
# B. Core loan calculation function (Separate Disbursements)
# ---------------------------------------------------------
def separate_disbursements_amortization(
    df_disb,               # DataFrame: [disbursement_date, amount]
    df_payments,           # DataFrame: [payment_date, amount]
    df_rate_schedule,      # DataFrame: [effective_date, annual_rate], optional
    default_annual_rate=0.084,  # fallback if no schedule applies
    monthly_emi=25000,           # user-chosen EMI
    start_payment_date=datetime(2025,5,1),
    max_months=216,        # up to 18 years
    simple_years=3         # 3-year simple interest window for each disb
):
    """
    Returns:
      - df_schedule: monthly aggregated schedule (DataFrame)
      - disbursements_list: final state of each disbursement
    """

    # Ensure correct dtypes
    df_disb['disbursement_date'] = pd.to_datetime(df_disb['disbursement_date'])
    df_payments['payment_date']  = pd.to_datetime(df_payments['payment_date'])

    # Sort data
    df_disb = df_disb.sort_values('disbursement_date').reset_index(drop=True)
    df_payments = df_payments.sort_values('payment_date').reset_index(drop=True)

    # Build a list of disbursements with tracking fields
    disbursements_list = []
    for i, row in df_disb.iterrows():
        disbursements_list.append({
            'id': i,
            'disbursement_date': row['disbursement_date'],
            'principal_outstanding': row['amount'],
            'accrued_simple_interest': 0.0  # interest in simple phase that hasn't been capitalized
        })

    # Create a monthly date range from start_payment_date up to max_months
    end_date = start_payment_date + pd.DateOffset(months=max_months)
    period_dates = pd.date_range(start=start_payment_date, end=end_date, freq='MS')  # Month start

    schedule_rows = []

    for period_idx, current_date in enumerate(period_dates, start=1):
        # 1) Check lumpsum payment on this date
        lumpsum_payment = df_payments.loc[df_payments['payment_date'] == current_date, 'amount'].sum()

        # 2) Calculate interest for each disbursement
        total_interest_this_month = 0.0
        disb_interest_list = []

        for disb in disbursements_list:
            # If fully cleared, skip
            if disb['principal_outstanding'] <= 0 and disb['accrued_simple_interest'] <= 0:
                disb_interest_list.append(0.0)
                continue

            # Fetch the correct annual rate for this month from schedule
            annual_rate = get_annual_rate_for_date(current_date, df_rate_schedule, default_annual_rate)
            monthly_rate = annual_rate / 12.0

            # Determine if still in simple interest window
            simple_phase_end = disb['disbursement_date'] + pd.DateOffset(years=simple_years)
            if current_date < simple_phase_end:
                # Simple interest = principal_outstanding * monthly_rate
                interest = disb['principal_outstanding'] * monthly_rate
            else:
                # Compound interest
                interest = disb['principal_outstanding'] * monthly_rate

            total_interest_this_month += interest
            disb_interest_list.append(interest)

        # 3) The user’s total payment for this month
        total_payment = monthly_emi + lumpsum_payment

        # 4a) Pay interest first (allocated proportionally)
        interest_paid_list = [0.0]*len(disbursements_list)
        principal_paid_list = [0.0]*len(disbursements_list)

        if total_interest_this_month > 0 and total_payment > 0:
            for i, disb in enumerate(disbursements_list):
                interest_portion = disb_interest_list[i]
                if interest_portion <= 0:
                    continue
                ratio = interest_portion / total_interest_this_month
                allocated_interest = total_payment * ratio
                # can't pay more than interest_portion
                interest_paid_list[i] = min(allocated_interest, interest_portion)
            interest_paid_sum = sum(interest_paid_list)
            total_payment -= interest_paid_sum
        else:
            interest_paid_sum = 0.0

        # 4b) Pay principal with leftover
        total_outstanding_principal = sum(d['principal_outstanding'] for d in disbursements_list if d['principal_outstanding']>0)
        if total_payment > 0 and total_outstanding_principal > 0:
            for i, disb in enumerate(disbursements_list):
                if disb['principal_outstanding'] > 0:
                    fraction = disb['principal_outstanding'] / total_outstanding_principal
                    allocated_principal = total_payment * fraction
                    principal_paid_list[i] = min(allocated_principal, disb['principal_outstanding'])
            principal_paid_sum = sum(principal_paid_list)
            total_payment -= principal_paid_sum
        else:
            principal_paid_sum = 0.0

        # 5) Update each disbursement
        for i, disb in enumerate(disbursements_list):
            interest_due = disb_interest_list[i]
            interest_paid = interest_paid_list[i]
            unpaid_interest = interest_due - interest_paid

            simple_phase_end = disb['disbursement_date'] + pd.DateOffset(years=simple_years)
            in_simple = (current_date < simple_phase_end)

            if in_simple:
                # Accumulate any unpaid interest in accrued_simple_interest
                disb['accrued_simple_interest'] += unpaid_interest
            else:
                # In compound phase, unpaid interest is capitalized
                disb['principal_outstanding'] += unpaid_interest

            # Subtract principal paid
            disb['principal_outstanding'] -= principal_paid_list[i]

            # If we've crossed from simple to compound, capitalize any leftover
            if not in_simple and disb['accrued_simple_interest'] > 0:
                disb['principal_outstanding'] += disb['accrued_simple_interest']
                disb['accrued_simple_interest'] = 0.0

        # Summaries for schedule
        total_principal_out = sum(d['principal_outstanding'] for d in disbursements_list if d['principal_outstanding']>0)
        total_accrued_si = sum(d['accrued_simple_interest'] for d in disbursements_list if d['accrued_simple_interest']>0)

        schedule_rows.append({
            'Period': period_idx,
            'Date': current_date,
            'Interest_This_Month': sum(disb_interest_list),
            'Interest_Paid': interest_paid_sum,
            'Principal_Paid': principal_paid_sum,
            'Extra_Payment': lumpsum_payment,
            'Ending_Total_Principal': total_principal_out,
            'Ending_Total_Simple_Interest': total_accrued_si
        })

        # Stop if fully paid
        if total_principal_out < 1e-8 and total_accrued_si < 1e-8:
            break

    df_schedule = pd.DataFrame(schedule_rows)
    return df_schedule, disbursements_list

# ---------------------------------------------------------
# C. Streamlit App
# ---------------------------------------------------------
def main():
    st.title("Dynamic Education Loan Calculator — Separate Disbursements + Floating Rate")
    st.markdown("""
    This app calculates your education loan repayment schedule, handling:
    - **Multiple disbursements** on different dates
    - **Simple interest** for 3 years from each disbursement date, then **compound interest**
    - **Floating interest rate**: provide a schedule of interest rates if needed
    - **Extra (lumpsum) payments** on specific dates
    - Adjust **Monthly EMI** and **Max Tenure**
    """)

    # Section 1: Disbursements
    st.header("1. Disbursements")
    st.write("Default data from your example. Edit or add rows as needed.")
    default_disb = pd.DataFrame({
        'disbursement_date': [
            '25-Sep-2023',
            '20-Dec-2023',
            '28-May-2024',
            '30-Aug-2024',
            '06-Dec-2024',
            '07-Dec-2024',
            '02-Jan-2025'
        ],
        'amount': [355000, 345000, 539000, 340000, 330000, 55000, 35000]
    })
    df_disb_user = st.experimental_data_editor(default_disb,
                                               num_rows="dynamic",
                                               use_container_width=True,
                                               key="disb_ed")

    # Section 2: Extra Payments
    st.header("2. Extra Payments (Optional)")
    st.write("Add lumpsum payments on specific dates if you plan them. Can be empty if none.")
    default_payments = pd.DataFrame({
        'payment_date': pd.Series([], dtype='str'),
        'amount': pd.Series([], dtype='float')
    })
    df_pay_user = st.experimental_data_editor(default_payments,
                                              num_rows="dynamic",
                                              use_container_width=True,
                                              key="pay_ed")

    # Section 3: Interest Rate Schedule (Optional)
    st.header("3. Interest Rate Schedule (Optional)")
    st.write("If your EBLR changes, define them here. If empty, we'll use the default rate at all times.")
    st.write("Use decimal form (e.g. 0.084 for 8.4%). 'effective_date' is when that rate begins.")
    default_rates = pd.DataFrame({
        'effective_date': pd.Series([], dtype='str'),
        'annual_rate': pd.Series([], dtype='float')
    })
    df_rate_user = st.experimental_data_editor(default_rates,
                                               num_rows="dynamic",
                                               use_container_width=True,
                                               key="rate_ed")

    # Section 4: Parameters
    st.header("4. Parameters")
    default_rate = st.number_input("Default Annual Interest Rate (decimal)",
                                   min_value=0.0,
                                   max_value=1.0,
                                   value=0.084,
                                   step=0.001,
                                   help="e.g. 0.084 = 8.4%, used if no schedule row applies")

    # Option A: Let user type EMI or
    # Option B: Provide a slider
    monthly_emi = st.slider("Monthly EMI", min_value=0, max_value=100000, step=5000, value=25000)

    start_date = st.date_input("Repayment Start Date", value=datetime(2025,5,1))
    max_months = st.number_input("Max Tenure in Months", min_value=12, max_value=360, value=216, step=12)
    simple_years = st.number_input("Simple Interest Period (Years from each Disb Date)",
                                   min_value=1, max_value=10, value=3, step=1)

    # Button to run calculation
    if st.button("Calculate Repayment Schedule"):
        df_schedule, final_disbs = separate_disbursements_amortization(
            df_disb=df_disb_user,
            df_payments=df_pay_user if not df_pay_user.empty else pd.DataFrame({'payment_date':[],'amount':[]}),
            df_rate_schedule=df_rate_user if not df_rate_user.empty else pd.DataFrame({'effective_date':[],'annual_rate':[]}),
            default_annual_rate=default_rate,
            monthly_emi=monthly_emi,
            start_payment_date=datetime(start_date.year, start_date.month, start_date.day),
            max_months=max_months,
            simple_years=simple_years
        )

        st.subheader("Repayment Schedule")
        if df_schedule.empty:
            st.warning("It appears no payments were computed. Perhaps the input data leads to no schedule or everything is zero.")
        else:
            st.dataframe(df_schedule)
            # Summaries
            total_interest_paid = df_schedule['Interest_Paid'].sum()
            months_taken = df_schedule['Period'].iloc[-1]
            final_principal = df_schedule['Ending_Total_Principal'].iloc[-1]
            final_simple_int = df_schedule['Ending_Total_Simple_Interest'].iloc[-1]

            st.write(f"**Total Interest Paid:** {total_interest_paid:,.2f}")
            st.write(f"**Months Taken to Repay (if fully repaid):** {months_taken}")
            st.write(f"**Final Outstanding Principal:** {final_principal:,.2f}")
            st.write(f"**Final Accrued Simple Interest:** {final_simple_int:,.2f}")

            # Chart: Principal Over Time
            fig = px.line(df_schedule, x='Date', y='Ending_Total_Principal',
                          title='Outstanding Principal Over Time')
            st.plotly_chart(fig, use_container_width=True)

            # Chart: Stacked bar of Interest vs. Principal Paid
            df_melted = df_schedule.melt(id_vars=['Period','Date'],
                                         value_vars=['Interest_Paid','Principal_Paid'],
                                         var_name='PaidType', value_name='Amount')
            fig2 = px.bar(df_melted, x='Date', y='Amount', color='PaidType',
                          barmode='stack', title='Monthly Interest vs. Principal Paid')
            st.plotly_chart(fig2, use_container_width=True)

if __name__ == "__main__":
    main()